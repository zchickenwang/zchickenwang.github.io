<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    font-weight: 300;
    font-family: 'Cardo', serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Averia Serif Libre', serif;
  }
  .text {
    width: 500px;
    text-indent: none;
    text-align: left;
    margin: auto;
  }
  h2 {
    color: #A0522D;
  }
  h3 {
    color: #DAA520;
  }
  h4 {
    color: #E6BE8A;
  }
  .pale {
    color:#E6BE8A;
  }

</style>
<title>CS 184 Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Averia+Serif+Libre|Cardo|Concert+One|Fredoka+One" rel="stylesheet">
</head>


<body>

<h1 align="middle" style="color:#A0522D;">CS 184: Computer Graphics and Imaging, Spring 2019</h1>
<h1 align="middle" style="color:#DAA520;">Project 1: Rasterizer</h1>
<h2 align="middle" class="pale">Z Wang</h2>

<br><br>

<div class="text">

<h2 align="middle">Overview</h2>
<p> &emsp;What are the challenges of displaying an image on a screen? Much of computer graphics we take for granted&mdash;how exactly are 3-dimensional spaces mapped (convincingly and quickly) onto a 2-d plane? How can we deal with different resolutions of images, and more interestingly, how does our approach change when dealing with graphics and viewpoints that move?
</br>
&emsp;This project begins with the fundamental problems of coloring pixels in a frame buffer and rendering triangles. We then explore supersampling as an anti-aliasing method, as well as transformations on shapes as a tool for creating complex graphics efficiently. Lastly, we'll see how barycentric coordinates can be used to map colors and textures onto on-screen shapes, leveraging techniques like bilinear sampling and mipmaps.
 </p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p>&emsp;The basic approach to rasterizing a triangle is by testing if each pixel lies within the triangle. This introduces some interesting subproblems:
<ul>
  <li>If a pixel has nonzero area, then which part of it's area do we use as a representative of the entire pixel?</li>
  <li>Given a coordinate and the vertices of a triangle, how can we tell if the coordinate lies within the triangle?</li>
</ul>
To deal with the first problem, we'll first go with the naive approach of using the center of each pixel as its sole representative. 
</p>

<h4 align="middle">Some Geometry</h4>
<p>
&emsp;Dealing with the second problem requires some basic coordinate geometry; here, the internet offers a variety of solutions:
<ul>
  <li>Testing if the point lies inside the half-plane of each of the triangle's edges&mdash;this is the method we will use.</li>
  <li>Given triangle vertices ABC and coordinate X, test if area(ABC) = area(ABX) + area(XBC) + area(AXC). There are off-the-shelf formulas for calculating area.</li>
  <li>Use barycentric coordinates&mdash;this'll be explained further in Part 4.</li>
  <li>"Find the vectors connecting the point to each of the triangle's three vertices and sum the angles between those vectors. If the sum of the angles is 2*pi then the point is inside the triangle." (<a href="https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle" target="_blank">source</a>)
</ul>
&emsp;Going with the first approach means first finding the vectors that represent the edges of the triangle. From each edge vector we can get it's normal vector (oriented toward inside the triangle&mdash;a key distinction). Then we can compute the cross-product of each normal vector with the vector from a point on the edge to the given coordinate. If this cross-product is positive, then the coordinate lies on the correct side of the edge (within 90 degrees of the normal). If it's negative, it's on the wrong side; and if it's zero, then it lies exactly 90 degrees from the normal.
</br>
&emsp;However, this approach isn't agnostic to the order in which the triangle's vertices is passed in. If the vertices are given in clockwise order, then the normals we want are on the right side of the edge. If counterclockwise, then they're on the left. To account for this, we'll ensure vertices are in counterclockwise order. If they aren't (which can be determined using <a href="https://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order" target="_blank">another formula</a>), then we'll swap the second and third vertices to get counterclockwise order.
</p>

<h4 align="middle">Algorithm</h4>
<p>
&emsp;Alright, so now we can tell if a point is within a triangle. Given a triangle and color, then, we can apply this test to the center of each pixel around the triangle&mdash;if the pixel center lies within the triangle, we'll color that pixel. But what does "around the triangle" mean? We wouldn't want to test every pixel on the screen, so instead let's find the bounding box of the given triangle by finding the min and max values of its vertices x and y coordinates. Running a loop like so:
<pre><code>
for (x = min_x; x < max_x; x++) {
  for (y = min_y; y < max_y; y++) {
    /* Color pixel (x, y) if (x+0.5, y+0.5) lies inside the triangle. */
  }
}
</code></pre>
will only explore pixels within the triangle's bounding box.
</p>

<h4 align="middle">Results</h4>
<p>
Here are some results we get:
</p>
</div>

<div align="middle">
  <table style="width=1000px, margin=auto">
    <tr>
      <td>
        <img src="images/part1-1.png" align="middle" width="400px"/>
        <figcaption align="middle">1a. Lots of triangles--looks pretty good.</figcaption>
      </td>
      <td>
        <img src="images/part1-2.png" align="middle" width="400px"/>
        <figcaption align="middle">1b. Hm. Maybe not...</figcaption>
      </td>
    </tr>
  </table>
</div>

<div class="text">
<h3 align="middle">Part 2: Antialiasing triangles</h3>
<p> The magnified shot in image 1b reveals a key weakness in our naive approach. If we only look at the center of each pixel, then our image can be significantly affected by "jaggies", or a lack of smoothness in shapes whose position change rapidly relative to our sampling rate, which in the naive case is simply 1 sample/pixel. In the 1b example, a very thin triangle can cross the centers of pixels somewhat arbitrarily&mdash;even if the triangle covers just under half of the pixel's area, it may not be colored if the center lies outside. This results in the stacatto, stairstep-like scattering of red lines.
</br>
One way around this problem is taking more samples in each pixel: supersampling. Here, we first define the number of samples taken per pixel&mdash;let's call this the sample-rate. Furthermore, let's distribute these samples evenly across the pixel (this is the most intuitive distribution, although perhaps giving more weight to samples closer to the center would produce better results).
</p>

<h4 align="middle">Algorithm</h4>
<p>
Now we need to change our algorithm: for each pixel, we'll run through another pair of x, y coordinate loops which traverse sample-rate points. If a point is within the triangle, we won't color the entire pixel, but color that subpixel. After running through the whole pixel, we can determine its color by averaging over all its subpixel colors (where the default is transparent). While this is all pretty straightforward, it's worth noting that type conversions and rounding in C++ gave me a fair bit of struggle.
</p>

<h4 align="middle">Results</h4>
<p>
Here's the same thin triangle edge over increasing sample-rate's:
</p>
</div>

<div align="middle">
  <table style="width=1000px, margin=auto">
    <tr>
      <td>
        <img src="images/part2-1.png" align="middle" width="400px"/>
        <figcaption align="middle">2a. The OG, 1 sample/pixel.</figcaption>
      </td>
      <td>
        <img src="images/part2-2.png" align="middle" width="400px"/>
        <figcaption align="middle">2b. 4 samples/pixel.</figcaption>
      </td>
    </tr>
    </br>
    <tr>
      <td>
        <img src="images/part2-3.png" align="middle" width="400px"/>
        <figcaption align="middle">2c. 9 samples/pixel.</figcaption>
      </td>
      <td>
        <img src="images/part2-4.png" align="middle" width="400px"/>
        <figcaption align="middle">2d. 16 samples/pixel.</figcaption>
      </td>
    </tr>
  </table>
</div>

<div class="text">
<p>
So why does this work? Let's consider a pixel whose top 40% area overlaps with the triangle. In our naive scheme, this pixel would have no color. Now, if we're using a sample rate of 9 and 4/9 of them lie within the triangle, then this pixel will be colored with 4/9'ths saturation. Viewed from afar, we get the impression that the pixel is half-colored, giving a much smoother look.
</p>

<h3 align="middle">Part 3: Transforms</h3>
<p>
Transforms are useful because a shape which is used in many different places, but is oriented or stretched in different ways, can be represented just once, and the others created via transforms on the original. We implemented three of the most fundamental: translations, scaling, and rotations. Using homogenous coordinates (where an additional dimension is added to incorporate translations), we created matrices for each transform. Input vectors (representing either points or directions) are multiplied with a matrix to transform it.
</br>
While we won't write out each matrix, they can be easily found <a href="https://en.wikipedia.org/wiki/Transformation_matrix" target="_blank">online</a>.
</p>

<h4 align="middle">Results</h4>
<p>
Here's a simple graphic of a red robot formed using transforms, as well as a version which I manipulated as :
</p>
</div>

<div align="middle">
  <table style="width=1000px, margin=auto">
    <tr>
      <td>
        <img src="images/part1-1.png" align="middle" width="400px"/>
        <figcaption align="middle">3a. Beep boop.</figcaption>
      </td>
      <td>
        <img src="images/part1-2.png" align="middle" width="400px"/>
        <figcaption align="middle">3b. ?</figcaption>
      </td>
    </tr>
  </table>
</div>

<div class="text">
<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>


<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>


<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>



<h2 align="middle">Section III: Art Competition</h2>
<p>If you are not participating in the optional art competition, don't worry about this section!</p>

<h3 align="middle">Part 7: Draw something interesting!</h3>
</div>
</body>
</html>
